# BFS 广度优先搜索
BFS 是一种 <font color="#dd0000">**遍历或搜索** </font>数据结构（如树或图）的算法。
- 解决问题：距离最短，次数最少，时间最短，连通块等图问题。
- 特性:第一次找到可能出现的结果就是最优的。
- 在树中执行层序遍历。
- 在图中找起始节点到目标节点的路径，通常找图中两点最短的路径。
在图中使用BFS要确定是四分点还是8分点。搜索时要判断该点是否非法，是否可达。

## 四分点
扫描上下左右垂直的点。
![四分点](images/four.jpg)
## 八分点
扫描周围的所有点。
![八分点](images/eight.jpg)

伪代码：
```
传入参数（根节点,目标节点）{
   存储所有等待处理的节点
   从根到当前节点的步数
   初始化
while(队列不为空){
  从根到当前节点的步数 += 1
  迭代队列中已经存在的节点{
   当前节点 = 队列中的第一个节点
   如果这个节点是目标节点就返回步数
   循环当前节点的下一个节点{
         添加到队列中
   }
   从队列中删除第一个节点
 } 
}
从根节点到目标没有路径 返回 -1    
}
function  bfs(){
    while queue is not empty
}
```

# 岛屿问题
```
输入:
11110
11010
11000
00000
输出: 1
```
遇到 1 就往四周扩展，查看是否越界，如果没有且有1，就继续向四周进行检查，遇到 0 就停止。
沉没：遇到1就把小岛沉没，变为0，就不会有重复的问题。

```
var numIslands = function(grid) {
    let count = 0;

    function dfs(i,j){
        //越界
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === "0")return;
        grid[i][j] = "0";
        dfs(i + 1, j);    // 搜索右边
        dfs(i - 1, j);    // 搜索左边
        dfs(i, j + 1);    // 搜索下边
        dfs(i, j - 1);    // 搜索上边
    }

    for(let i = 0; i < grid.length; i++){ 
        for(let j = 0; j < grid[0].length; j++){ 
            if(grid[i][j] === "1"){
                count++;
                dfs(i , j); //当前点到的位置,dfs深度优先，先走一条路走完
            }
        }

    }
    return count;
}
```